{"ast":null,"code":"import { RotateDirection, clamp, getDistance, getDistances, getRandom, getRangeValue } from \"@tsparticles/engine\";\nconst half = 0.5,\n  double = 2,\n  minVelocity = 0,\n  identity = 1,\n  moveSpeedFactor = 60,\n  minSpinRadius = 0,\n  spinFactor = 0.01,\n  doublePI = Math.PI * double;\nexport function applyDistance(particle) {\n  var _ref, _ref2;\n  const initialPosition = particle.initialPosition,\n    {\n      dx,\n      dy\n    } = getDistances(initialPosition, particle.position),\n    dxFixed = Math.abs(dx),\n    dyFixed = Math.abs(dy),\n    {\n      maxDistance\n    } = particle.retina,\n    hDistance = maxDistance.horizontal,\n    vDistance = maxDistance.vertical;\n  if (!hDistance && !vDistance) {\n    return;\n  }\n  const hasHDistance = (_ref = hDistance && dxFixed >= hDistance) !== null && _ref !== void 0 ? _ref : false,\n    hasVDistance = (_ref2 = vDistance && dyFixed >= vDistance) !== null && _ref2 !== void 0 ? _ref2 : false;\n  if ((hasHDistance || hasVDistance) && !particle.misplaced) {\n    particle.misplaced = !!hDistance && dxFixed > hDistance || !!vDistance && dyFixed > vDistance;\n    if (hDistance) {\n      particle.velocity.x = particle.velocity.y * half - particle.velocity.x;\n    }\n    if (vDistance) {\n      particle.velocity.y = particle.velocity.x * half - particle.velocity.y;\n    }\n  } else if ((!hDistance || dxFixed < hDistance) && (!vDistance || dyFixed < vDistance) && particle.misplaced) {\n    particle.misplaced = false;\n  } else if (particle.misplaced) {\n    const pos = particle.position,\n      vel = particle.velocity;\n    if (hDistance && (pos.x < initialPosition.x && vel.x < minVelocity || pos.x > initialPosition.x && vel.x > minVelocity)) {\n      vel.x *= -getRandom();\n    }\n    if (vDistance && (pos.y < initialPosition.y && vel.y < minVelocity || pos.y > initialPosition.y && vel.y > minVelocity)) {\n      vel.y *= -getRandom();\n    }\n  }\n}\nexport function move(particle, moveOptions, moveSpeed, maxSpeed, moveDrift, reduceFactor, delta) {\n  applyPath(particle, delta);\n  const gravityOptions = particle.gravity,\n    gravityFactor = gravityOptions !== null && gravityOptions !== void 0 && gravityOptions.enable && gravityOptions.inverse ? -identity : identity;\n  if (moveDrift && moveSpeed) {\n    particle.velocity.x += moveDrift * delta.factor / (moveSpeedFactor * moveSpeed);\n  }\n  if (gravityOptions !== null && gravityOptions !== void 0 && gravityOptions.enable && moveSpeed) {\n    particle.velocity.y += gravityFactor * (gravityOptions.acceleration * delta.factor) / (moveSpeedFactor * moveSpeed);\n  }\n  const decay = particle.moveDecay;\n  particle.velocity.multTo(decay);\n  const velocity = particle.velocity.mult(moveSpeed);\n  if (gravityOptions !== null && gravityOptions !== void 0 && gravityOptions.enable && maxSpeed > minVelocity && (!gravityOptions.inverse && velocity.y >= minVelocity && velocity.y >= maxSpeed || gravityOptions.inverse && velocity.y <= minVelocity && velocity.y <= -maxSpeed)) {\n    velocity.y = gravityFactor * maxSpeed;\n    if (moveSpeed) {\n      particle.velocity.y = velocity.y / moveSpeed;\n    }\n  }\n  const zIndexOptions = particle.options.zIndex,\n    zVelocityFactor = (identity - particle.zIndexFactor) ** zIndexOptions.velocityRate;\n  velocity.multTo(zVelocityFactor);\n  velocity.multTo(reduceFactor);\n  const {\n    position\n  } = particle;\n  position.addTo(velocity);\n  if (moveOptions.vibrate) {\n    position.x += Math.sin(position.x * Math.cos(position.y)) * reduceFactor;\n    position.y += Math.cos(position.y * Math.sin(position.x)) * reduceFactor;\n  }\n}\nexport function spin(particle, moveSpeed, reduceFactor) {\n  const container = particle.container;\n  if (!particle.spin) {\n    return;\n  }\n  const spinClockwise = particle.spin.direction === RotateDirection.clockwise,\n    updateFunc = {\n      x: spinClockwise ? Math.cos : Math.sin,\n      y: spinClockwise ? Math.sin : Math.cos\n    };\n  particle.position.x = particle.spin.center.x + particle.spin.radius * updateFunc.x(particle.spin.angle) * reduceFactor;\n  particle.position.y = particle.spin.center.y + particle.spin.radius * updateFunc.y(particle.spin.angle) * reduceFactor;\n  particle.spin.radius += particle.spin.acceleration * reduceFactor;\n  const maxCanvasSize = Math.max(container.canvas.size.width, container.canvas.size.height),\n    halfMaxSize = maxCanvasSize * half;\n  if (particle.spin.radius > halfMaxSize) {\n    particle.spin.radius = halfMaxSize;\n    particle.spin.acceleration *= -identity;\n  } else if (particle.spin.radius < minSpinRadius) {\n    particle.spin.radius = minSpinRadius;\n    particle.spin.acceleration *= -identity;\n  }\n  particle.spin.angle += moveSpeed * spinFactor * (identity - particle.spin.radius / maxCanvasSize);\n}\nexport function applyPath(particle, delta) {\n  var _particle$pathGenerat;\n  const particlesOptions = particle.options,\n    pathOptions = particlesOptions.move.path,\n    pathEnabled = pathOptions.enable;\n  if (!pathEnabled) {\n    return;\n  }\n  if (particle.lastPathTime <= particle.pathDelay) {\n    particle.lastPathTime += delta.value;\n    return;\n  }\n  const path = (_particle$pathGenerat = particle.pathGenerator) === null || _particle$pathGenerat === void 0 ? void 0 : _particle$pathGenerat.generate(particle, delta);\n  if (path) {\n    particle.velocity.addTo(path);\n  }\n  if (pathOptions.clamp) {\n    particle.velocity.x = clamp(particle.velocity.x, -identity, identity);\n    particle.velocity.y = clamp(particle.velocity.y, -identity, identity);\n  }\n  particle.lastPathTime -= particle.pathDelay;\n}\nexport function getProximitySpeedFactor(particle) {\n  return particle.slow.inRange ? particle.slow.factor : identity;\n}\nexport function initSpin(particle) {\n  var _spinOptions$position;\n  const container = particle.container,\n    options = particle.options,\n    spinOptions = options.move.spin;\n  if (!spinOptions.enable) {\n    return;\n  }\n  const spinPos = (_spinOptions$position = spinOptions.position) !== null && _spinOptions$position !== void 0 ? _spinOptions$position : {\n      x: 50,\n      y: 50\n    },\n    spinFactor = 0.01,\n    spinCenter = {\n      x: spinPos.x * spinFactor * container.canvas.size.width,\n      y: spinPos.y * spinFactor * container.canvas.size.height\n    },\n    pos = particle.getPosition(),\n    distance = getDistance(pos, spinCenter),\n    spinAcceleration = getRangeValue(spinOptions.acceleration);\n  particle.retina.spinAcceleration = spinAcceleration * container.retina.pixelRatio;\n  particle.spin = {\n    center: spinCenter,\n    direction: particle.velocity.x >= minVelocity ? RotateDirection.clockwise : RotateDirection.counterClockwise,\n    angle: getRandom() * doublePI,\n    radius: distance,\n    acceleration: particle.retina.spinAcceleration\n  };\n}","map":{"version":3,"names":["RotateDirection","clamp","getDistance","getDistances","getRandom","getRangeValue","half","double","minVelocity","identity","moveSpeedFactor","minSpinRadius","spinFactor","doublePI","Math","PI","applyDistance","particle","_ref","_ref2","initialPosition","dx","dy","position","dxFixed","abs","dyFixed","maxDistance","retina","hDistance","horizontal","vDistance","vertical","hasHDistance","hasVDistance","misplaced","velocity","x","y","pos","vel","move","moveOptions","moveSpeed","maxSpeed","moveDrift","reduceFactor","delta","applyPath","gravityOptions","gravity","gravityFactor","enable","inverse","factor","acceleration","decay","moveDecay","multTo","mult","zIndexOptions","options","zIndex","zVelocityFactor","zIndexFactor","velocityRate","addTo","vibrate","sin","cos","spin","container","spinClockwise","direction","clockwise","updateFunc","center","radius","angle","maxCanvasSize","max","canvas","size","width","height","halfMaxSize","_particle$pathGenerat","particlesOptions","pathOptions","path","pathEnabled","lastPathTime","pathDelay","value","pathGenerator","generate","getProximitySpeedFactor","slow","inRange","initSpin","_spinOptions$position","spinOptions","spinPos","spinCenter","getPosition","distance","spinAcceleration","pixelRatio","counterClockwise"],"sources":["C:/Users/Joey/Documents/Website/node_modules/@tsparticles/move-base/browser/Utils.js"],"sourcesContent":["import { RotateDirection, clamp, getDistance, getDistances, getRandom, getRangeValue, } from \"@tsparticles/engine\";\nconst half = 0.5, double = 2, minVelocity = 0, identity = 1, moveSpeedFactor = 60, minSpinRadius = 0, spinFactor = 0.01, doublePI = Math.PI * double;\nexport function applyDistance(particle) {\n    const initialPosition = particle.initialPosition, { dx, dy } = getDistances(initialPosition, particle.position), dxFixed = Math.abs(dx), dyFixed = Math.abs(dy), { maxDistance } = particle.retina, hDistance = maxDistance.horizontal, vDistance = maxDistance.vertical;\n    if (!hDistance && !vDistance) {\n        return;\n    }\n    const hasHDistance = (hDistance && dxFixed >= hDistance) ?? false, hasVDistance = (vDistance && dyFixed >= vDistance) ?? false;\n    if ((hasHDistance || hasVDistance) && !particle.misplaced) {\n        particle.misplaced = (!!hDistance && dxFixed > hDistance) || (!!vDistance && dyFixed > vDistance);\n        if (hDistance) {\n            particle.velocity.x = particle.velocity.y * half - particle.velocity.x;\n        }\n        if (vDistance) {\n            particle.velocity.y = particle.velocity.x * half - particle.velocity.y;\n        }\n    }\n    else if ((!hDistance || dxFixed < hDistance) && (!vDistance || dyFixed < vDistance) && particle.misplaced) {\n        particle.misplaced = false;\n    }\n    else if (particle.misplaced) {\n        const pos = particle.position, vel = particle.velocity;\n        if (hDistance &&\n            ((pos.x < initialPosition.x && vel.x < minVelocity) || (pos.x > initialPosition.x && vel.x > minVelocity))) {\n            vel.x *= -getRandom();\n        }\n        if (vDistance &&\n            ((pos.y < initialPosition.y && vel.y < minVelocity) || (pos.y > initialPosition.y && vel.y > minVelocity))) {\n            vel.y *= -getRandom();\n        }\n    }\n}\nexport function move(particle, moveOptions, moveSpeed, maxSpeed, moveDrift, reduceFactor, delta) {\n    applyPath(particle, delta);\n    const gravityOptions = particle.gravity, gravityFactor = gravityOptions?.enable && gravityOptions.inverse ? -identity : identity;\n    if (moveDrift && moveSpeed) {\n        particle.velocity.x += (moveDrift * delta.factor) / (moveSpeedFactor * moveSpeed);\n    }\n    if (gravityOptions?.enable && moveSpeed) {\n        particle.velocity.y +=\n            (gravityFactor * (gravityOptions.acceleration * delta.factor)) / (moveSpeedFactor * moveSpeed);\n    }\n    const decay = particle.moveDecay;\n    particle.velocity.multTo(decay);\n    const velocity = particle.velocity.mult(moveSpeed);\n    if (gravityOptions?.enable &&\n        maxSpeed > minVelocity &&\n        ((!gravityOptions.inverse && velocity.y >= minVelocity && velocity.y >= maxSpeed) ||\n            (gravityOptions.inverse && velocity.y <= minVelocity && velocity.y <= -maxSpeed))) {\n        velocity.y = gravityFactor * maxSpeed;\n        if (moveSpeed) {\n            particle.velocity.y = velocity.y / moveSpeed;\n        }\n    }\n    const zIndexOptions = particle.options.zIndex, zVelocityFactor = (identity - particle.zIndexFactor) ** zIndexOptions.velocityRate;\n    velocity.multTo(zVelocityFactor);\n    velocity.multTo(reduceFactor);\n    const { position } = particle;\n    position.addTo(velocity);\n    if (moveOptions.vibrate) {\n        position.x += Math.sin(position.x * Math.cos(position.y)) * reduceFactor;\n        position.y += Math.cos(position.y * Math.sin(position.x)) * reduceFactor;\n    }\n}\nexport function spin(particle, moveSpeed, reduceFactor) {\n    const container = particle.container;\n    if (!particle.spin) {\n        return;\n    }\n    const spinClockwise = particle.spin.direction === RotateDirection.clockwise, updateFunc = {\n        x: spinClockwise ? Math.cos : Math.sin,\n        y: spinClockwise ? Math.sin : Math.cos,\n    };\n    particle.position.x =\n        particle.spin.center.x + particle.spin.radius * updateFunc.x(particle.spin.angle) * reduceFactor;\n    particle.position.y =\n        particle.spin.center.y + particle.spin.radius * updateFunc.y(particle.spin.angle) * reduceFactor;\n    particle.spin.radius += particle.spin.acceleration * reduceFactor;\n    const maxCanvasSize = Math.max(container.canvas.size.width, container.canvas.size.height), halfMaxSize = maxCanvasSize * half;\n    if (particle.spin.radius > halfMaxSize) {\n        particle.spin.radius = halfMaxSize;\n        particle.spin.acceleration *= -identity;\n    }\n    else if (particle.spin.radius < minSpinRadius) {\n        particle.spin.radius = minSpinRadius;\n        particle.spin.acceleration *= -identity;\n    }\n    particle.spin.angle += moveSpeed * spinFactor * (identity - particle.spin.radius / maxCanvasSize);\n}\nexport function applyPath(particle, delta) {\n    const particlesOptions = particle.options, pathOptions = particlesOptions.move.path, pathEnabled = pathOptions.enable;\n    if (!pathEnabled) {\n        return;\n    }\n    if (particle.lastPathTime <= particle.pathDelay) {\n        particle.lastPathTime += delta.value;\n        return;\n    }\n    const path = particle.pathGenerator?.generate(particle, delta);\n    if (path) {\n        particle.velocity.addTo(path);\n    }\n    if (pathOptions.clamp) {\n        particle.velocity.x = clamp(particle.velocity.x, -identity, identity);\n        particle.velocity.y = clamp(particle.velocity.y, -identity, identity);\n    }\n    particle.lastPathTime -= particle.pathDelay;\n}\nexport function getProximitySpeedFactor(particle) {\n    return particle.slow.inRange ? particle.slow.factor : identity;\n}\nexport function initSpin(particle) {\n    const container = particle.container, options = particle.options, spinOptions = options.move.spin;\n    if (!spinOptions.enable) {\n        return;\n    }\n    const spinPos = spinOptions.position ?? { x: 50, y: 50 }, spinFactor = 0.01, spinCenter = {\n        x: spinPos.x * spinFactor * container.canvas.size.width,\n        y: spinPos.y * spinFactor * container.canvas.size.height,\n    }, pos = particle.getPosition(), distance = getDistance(pos, spinCenter), spinAcceleration = getRangeValue(spinOptions.acceleration);\n    particle.retina.spinAcceleration = spinAcceleration * container.retina.pixelRatio;\n    particle.spin = {\n        center: spinCenter,\n        direction: particle.velocity.x >= minVelocity ? RotateDirection.clockwise : RotateDirection.counterClockwise,\n        angle: getRandom() * doublePI,\n        radius: distance,\n        acceleration: particle.retina.spinAcceleration,\n    };\n}\n"],"mappings":"AAAA,SAASA,eAAe,EAAEC,KAAK,EAAEC,WAAW,EAAEC,YAAY,EAAEC,SAAS,EAAEC,aAAa,QAAS,qBAAqB;AAClH,MAAMC,IAAI,GAAG,GAAG;EAAEC,MAAM,GAAG,CAAC;EAAEC,WAAW,GAAG,CAAC;EAAEC,QAAQ,GAAG,CAAC;EAAEC,eAAe,GAAG,EAAE;EAAEC,aAAa,GAAG,CAAC;EAAEC,UAAU,GAAG,IAAI;EAAEC,QAAQ,GAAGC,IAAI,CAACC,EAAE,GAAGR,MAAM;AACpJ,OAAO,SAASS,aAAaA,CAACC,QAAQ,EAAE;EAAA,IAAAC,IAAA,EAAAC,KAAA;EACpC,MAAMC,eAAe,GAAGH,QAAQ,CAACG,eAAe;IAAE;MAAEC,EAAE;MAAEC;IAAG,CAAC,GAAGnB,YAAY,CAACiB,eAAe,EAAEH,QAAQ,CAACM,QAAQ,CAAC;IAAEC,OAAO,GAAGV,IAAI,CAACW,GAAG,CAACJ,EAAE,CAAC;IAAEK,OAAO,GAAGZ,IAAI,CAACW,GAAG,CAACH,EAAE,CAAC;IAAE;MAAEK;IAAY,CAAC,GAAGV,QAAQ,CAACW,MAAM;IAAEC,SAAS,GAAGF,WAAW,CAACG,UAAU;IAAEC,SAAS,GAAGJ,WAAW,CAACK,QAAQ;EACxQ,IAAI,CAACH,SAAS,IAAI,CAACE,SAAS,EAAE;IAC1B;EACJ;EACA,MAAME,YAAY,IAAAf,IAAA,GAAIW,SAAS,IAAIL,OAAO,IAAIK,SAAS,cAAAX,IAAA,cAAAA,IAAA,GAAK,KAAK;IAAEgB,YAAY,IAAAf,KAAA,GAAIY,SAAS,IAAIL,OAAO,IAAIK,SAAS,cAAAZ,KAAA,cAAAA,KAAA,GAAK,KAAK;EAC9H,IAAI,CAACc,YAAY,IAAIC,YAAY,KAAK,CAACjB,QAAQ,CAACkB,SAAS,EAAE;IACvDlB,QAAQ,CAACkB,SAAS,GAAI,CAAC,CAACN,SAAS,IAAIL,OAAO,GAAGK,SAAS,IAAM,CAAC,CAACE,SAAS,IAAIL,OAAO,GAAGK,SAAU;IACjG,IAAIF,SAAS,EAAE;MACXZ,QAAQ,CAACmB,QAAQ,CAACC,CAAC,GAAGpB,QAAQ,CAACmB,QAAQ,CAACE,CAAC,GAAGhC,IAAI,GAAGW,QAAQ,CAACmB,QAAQ,CAACC,CAAC;IAC1E;IACA,IAAIN,SAAS,EAAE;MACXd,QAAQ,CAACmB,QAAQ,CAACE,CAAC,GAAGrB,QAAQ,CAACmB,QAAQ,CAACC,CAAC,GAAG/B,IAAI,GAAGW,QAAQ,CAACmB,QAAQ,CAACE,CAAC;IAC1E;EACJ,CAAC,MACI,IAAI,CAAC,CAACT,SAAS,IAAIL,OAAO,GAAGK,SAAS,MAAM,CAACE,SAAS,IAAIL,OAAO,GAAGK,SAAS,CAAC,IAAId,QAAQ,CAACkB,SAAS,EAAE;IACvGlB,QAAQ,CAACkB,SAAS,GAAG,KAAK;EAC9B,CAAC,MACI,IAAIlB,QAAQ,CAACkB,SAAS,EAAE;IACzB,MAAMI,GAAG,GAAGtB,QAAQ,CAACM,QAAQ;MAAEiB,GAAG,GAAGvB,QAAQ,CAACmB,QAAQ;IACtD,IAAIP,SAAS,KACPU,GAAG,CAACF,CAAC,GAAGjB,eAAe,CAACiB,CAAC,IAAIG,GAAG,CAACH,CAAC,GAAG7B,WAAW,IAAM+B,GAAG,CAACF,CAAC,GAAGjB,eAAe,CAACiB,CAAC,IAAIG,GAAG,CAACH,CAAC,GAAG7B,WAAY,CAAC,EAAE;MAC5GgC,GAAG,CAACH,CAAC,IAAI,CAACjC,SAAS,CAAC,CAAC;IACzB;IACA,IAAI2B,SAAS,KACPQ,GAAG,CAACD,CAAC,GAAGlB,eAAe,CAACkB,CAAC,IAAIE,GAAG,CAACF,CAAC,GAAG9B,WAAW,IAAM+B,GAAG,CAACD,CAAC,GAAGlB,eAAe,CAACkB,CAAC,IAAIE,GAAG,CAACF,CAAC,GAAG9B,WAAY,CAAC,EAAE;MAC5GgC,GAAG,CAACF,CAAC,IAAI,CAAClC,SAAS,CAAC,CAAC;IACzB;EACJ;AACJ;AACA,OAAO,SAASqC,IAAIA,CAACxB,QAAQ,EAAEyB,WAAW,EAAEC,SAAS,EAAEC,QAAQ,EAAEC,SAAS,EAAEC,YAAY,EAAEC,KAAK,EAAE;EAC7FC,SAAS,CAAC/B,QAAQ,EAAE8B,KAAK,CAAC;EAC1B,MAAME,cAAc,GAAGhC,QAAQ,CAACiC,OAAO;IAAEC,aAAa,GAAGF,cAAc,aAAdA,cAAc,eAAdA,cAAc,CAAEG,MAAM,IAAIH,cAAc,CAACI,OAAO,GAAG,CAAC5C,QAAQ,GAAGA,QAAQ;EAChI,IAAIoC,SAAS,IAAIF,SAAS,EAAE;IACxB1B,QAAQ,CAACmB,QAAQ,CAACC,CAAC,IAAKQ,SAAS,GAAGE,KAAK,CAACO,MAAM,IAAK5C,eAAe,GAAGiC,SAAS,CAAC;EACrF;EACA,IAAIM,cAAc,aAAdA,cAAc,eAAdA,cAAc,CAAEG,MAAM,IAAIT,SAAS,EAAE;IACrC1B,QAAQ,CAACmB,QAAQ,CAACE,CAAC,IACda,aAAa,IAAIF,cAAc,CAACM,YAAY,GAAGR,KAAK,CAACO,MAAM,CAAC,IAAK5C,eAAe,GAAGiC,SAAS,CAAC;EACtG;EACA,MAAMa,KAAK,GAAGvC,QAAQ,CAACwC,SAAS;EAChCxC,QAAQ,CAACmB,QAAQ,CAACsB,MAAM,CAACF,KAAK,CAAC;EAC/B,MAAMpB,QAAQ,GAAGnB,QAAQ,CAACmB,QAAQ,CAACuB,IAAI,CAAChB,SAAS,CAAC;EAClD,IAAIM,cAAc,aAAdA,cAAc,eAAdA,cAAc,CAAEG,MAAM,IACtBR,QAAQ,GAAGpC,WAAW,KACpB,CAACyC,cAAc,CAACI,OAAO,IAAIjB,QAAQ,CAACE,CAAC,IAAI9B,WAAW,IAAI4B,QAAQ,CAACE,CAAC,IAAIM,QAAQ,IAC3EK,cAAc,CAACI,OAAO,IAAIjB,QAAQ,CAACE,CAAC,IAAI9B,WAAW,IAAI4B,QAAQ,CAACE,CAAC,IAAI,CAACM,QAAS,CAAC,EAAE;IACvFR,QAAQ,CAACE,CAAC,GAAGa,aAAa,GAAGP,QAAQ;IACrC,IAAID,SAAS,EAAE;MACX1B,QAAQ,CAACmB,QAAQ,CAACE,CAAC,GAAGF,QAAQ,CAACE,CAAC,GAAGK,SAAS;IAChD;EACJ;EACA,MAAMiB,aAAa,GAAG3C,QAAQ,CAAC4C,OAAO,CAACC,MAAM;IAAEC,eAAe,GAAG,CAACtD,QAAQ,GAAGQ,QAAQ,CAAC+C,YAAY,KAAKJ,aAAa,CAACK,YAAY;EACjI7B,QAAQ,CAACsB,MAAM,CAACK,eAAe,CAAC;EAChC3B,QAAQ,CAACsB,MAAM,CAACZ,YAAY,CAAC;EAC7B,MAAM;IAAEvB;EAAS,CAAC,GAAGN,QAAQ;EAC7BM,QAAQ,CAAC2C,KAAK,CAAC9B,QAAQ,CAAC;EACxB,IAAIM,WAAW,CAACyB,OAAO,EAAE;IACrB5C,QAAQ,CAACc,CAAC,IAAIvB,IAAI,CAACsD,GAAG,CAAC7C,QAAQ,CAACc,CAAC,GAAGvB,IAAI,CAACuD,GAAG,CAAC9C,QAAQ,CAACe,CAAC,CAAC,CAAC,GAAGQ,YAAY;IACxEvB,QAAQ,CAACe,CAAC,IAAIxB,IAAI,CAACuD,GAAG,CAAC9C,QAAQ,CAACe,CAAC,GAAGxB,IAAI,CAACsD,GAAG,CAAC7C,QAAQ,CAACc,CAAC,CAAC,CAAC,GAAGS,YAAY;EAC5E;AACJ;AACA,OAAO,SAASwB,IAAIA,CAACrD,QAAQ,EAAE0B,SAAS,EAAEG,YAAY,EAAE;EACpD,MAAMyB,SAAS,GAAGtD,QAAQ,CAACsD,SAAS;EACpC,IAAI,CAACtD,QAAQ,CAACqD,IAAI,EAAE;IAChB;EACJ;EACA,MAAME,aAAa,GAAGvD,QAAQ,CAACqD,IAAI,CAACG,SAAS,KAAKzE,eAAe,CAAC0E,SAAS;IAAEC,UAAU,GAAG;MACtFtC,CAAC,EAAEmC,aAAa,GAAG1D,IAAI,CAACuD,GAAG,GAAGvD,IAAI,CAACsD,GAAG;MACtC9B,CAAC,EAAEkC,aAAa,GAAG1D,IAAI,CAACsD,GAAG,GAAGtD,IAAI,CAACuD;IACvC,CAAC;EACDpD,QAAQ,CAACM,QAAQ,CAACc,CAAC,GACfpB,QAAQ,CAACqD,IAAI,CAACM,MAAM,CAACvC,CAAC,GAAGpB,QAAQ,CAACqD,IAAI,CAACO,MAAM,GAAGF,UAAU,CAACtC,CAAC,CAACpB,QAAQ,CAACqD,IAAI,CAACQ,KAAK,CAAC,GAAGhC,YAAY;EACpG7B,QAAQ,CAACM,QAAQ,CAACe,CAAC,GACfrB,QAAQ,CAACqD,IAAI,CAACM,MAAM,CAACtC,CAAC,GAAGrB,QAAQ,CAACqD,IAAI,CAACO,MAAM,GAAGF,UAAU,CAACrC,CAAC,CAACrB,QAAQ,CAACqD,IAAI,CAACQ,KAAK,CAAC,GAAGhC,YAAY;EACpG7B,QAAQ,CAACqD,IAAI,CAACO,MAAM,IAAI5D,QAAQ,CAACqD,IAAI,CAACf,YAAY,GAAGT,YAAY;EACjE,MAAMiC,aAAa,GAAGjE,IAAI,CAACkE,GAAG,CAACT,SAAS,CAACU,MAAM,CAACC,IAAI,CAACC,KAAK,EAAEZ,SAAS,CAACU,MAAM,CAACC,IAAI,CAACE,MAAM,CAAC;IAAEC,WAAW,GAAGN,aAAa,GAAGzE,IAAI;EAC7H,IAAIW,QAAQ,CAACqD,IAAI,CAACO,MAAM,GAAGQ,WAAW,EAAE;IACpCpE,QAAQ,CAACqD,IAAI,CAACO,MAAM,GAAGQ,WAAW;IAClCpE,QAAQ,CAACqD,IAAI,CAACf,YAAY,IAAI,CAAC9C,QAAQ;EAC3C,CAAC,MACI,IAAIQ,QAAQ,CAACqD,IAAI,CAACO,MAAM,GAAGlE,aAAa,EAAE;IAC3CM,QAAQ,CAACqD,IAAI,CAACO,MAAM,GAAGlE,aAAa;IACpCM,QAAQ,CAACqD,IAAI,CAACf,YAAY,IAAI,CAAC9C,QAAQ;EAC3C;EACAQ,QAAQ,CAACqD,IAAI,CAACQ,KAAK,IAAInC,SAAS,GAAG/B,UAAU,IAAIH,QAAQ,GAAGQ,QAAQ,CAACqD,IAAI,CAACO,MAAM,GAAGE,aAAa,CAAC;AACrG;AACA,OAAO,SAAS/B,SAASA,CAAC/B,QAAQ,EAAE8B,KAAK,EAAE;EAAA,IAAAuC,qBAAA;EACvC,MAAMC,gBAAgB,GAAGtE,QAAQ,CAAC4C,OAAO;IAAE2B,WAAW,GAAGD,gBAAgB,CAAC9C,IAAI,CAACgD,IAAI;IAAEC,WAAW,GAAGF,WAAW,CAACpC,MAAM;EACrH,IAAI,CAACsC,WAAW,EAAE;IACd;EACJ;EACA,IAAIzE,QAAQ,CAAC0E,YAAY,IAAI1E,QAAQ,CAAC2E,SAAS,EAAE;IAC7C3E,QAAQ,CAAC0E,YAAY,IAAI5C,KAAK,CAAC8C,KAAK;IACpC;EACJ;EACA,MAAMJ,IAAI,IAAAH,qBAAA,GAAGrE,QAAQ,CAAC6E,aAAa,cAAAR,qBAAA,uBAAtBA,qBAAA,CAAwBS,QAAQ,CAAC9E,QAAQ,EAAE8B,KAAK,CAAC;EAC9D,IAAI0C,IAAI,EAAE;IACNxE,QAAQ,CAACmB,QAAQ,CAAC8B,KAAK,CAACuB,IAAI,CAAC;EACjC;EACA,IAAID,WAAW,CAACvF,KAAK,EAAE;IACnBgB,QAAQ,CAACmB,QAAQ,CAACC,CAAC,GAAGpC,KAAK,CAACgB,QAAQ,CAACmB,QAAQ,CAACC,CAAC,EAAE,CAAC5B,QAAQ,EAAEA,QAAQ,CAAC;IACrEQ,QAAQ,CAACmB,QAAQ,CAACE,CAAC,GAAGrC,KAAK,CAACgB,QAAQ,CAACmB,QAAQ,CAACE,CAAC,EAAE,CAAC7B,QAAQ,EAAEA,QAAQ,CAAC;EACzE;EACAQ,QAAQ,CAAC0E,YAAY,IAAI1E,QAAQ,CAAC2E,SAAS;AAC/C;AACA,OAAO,SAASI,uBAAuBA,CAAC/E,QAAQ,EAAE;EAC9C,OAAOA,QAAQ,CAACgF,IAAI,CAACC,OAAO,GAAGjF,QAAQ,CAACgF,IAAI,CAAC3C,MAAM,GAAG7C,QAAQ;AAClE;AACA,OAAO,SAAS0F,QAAQA,CAAClF,QAAQ,EAAE;EAAA,IAAAmF,qBAAA;EAC/B,MAAM7B,SAAS,GAAGtD,QAAQ,CAACsD,SAAS;IAAEV,OAAO,GAAG5C,QAAQ,CAAC4C,OAAO;IAAEwC,WAAW,GAAGxC,OAAO,CAACpB,IAAI,CAAC6B,IAAI;EACjG,IAAI,CAAC+B,WAAW,CAACjD,MAAM,EAAE;IACrB;EACJ;EACA,MAAMkD,OAAO,IAAAF,qBAAA,GAAGC,WAAW,CAAC9E,QAAQ,cAAA6E,qBAAA,cAAAA,qBAAA,GAAI;MAAE/D,CAAC,EAAE,EAAE;MAAEC,CAAC,EAAE;IAAG,CAAC;IAAE1B,UAAU,GAAG,IAAI;IAAE2F,UAAU,GAAG;MACtFlE,CAAC,EAAEiE,OAAO,CAACjE,CAAC,GAAGzB,UAAU,GAAG2D,SAAS,CAACU,MAAM,CAACC,IAAI,CAACC,KAAK;MACvD7C,CAAC,EAAEgE,OAAO,CAAChE,CAAC,GAAG1B,UAAU,GAAG2D,SAAS,CAACU,MAAM,CAACC,IAAI,CAACE;IACtD,CAAC;IAAE7C,GAAG,GAAGtB,QAAQ,CAACuF,WAAW,CAAC,CAAC;IAAEC,QAAQ,GAAGvG,WAAW,CAACqC,GAAG,EAAEgE,UAAU,CAAC;IAAEG,gBAAgB,GAAGrG,aAAa,CAACgG,WAAW,CAAC9C,YAAY,CAAC;EACpItC,QAAQ,CAACW,MAAM,CAAC8E,gBAAgB,GAAGA,gBAAgB,GAAGnC,SAAS,CAAC3C,MAAM,CAAC+E,UAAU;EACjF1F,QAAQ,CAACqD,IAAI,GAAG;IACZM,MAAM,EAAE2B,UAAU;IAClB9B,SAAS,EAAExD,QAAQ,CAACmB,QAAQ,CAACC,CAAC,IAAI7B,WAAW,GAAGR,eAAe,CAAC0E,SAAS,GAAG1E,eAAe,CAAC4G,gBAAgB;IAC5G9B,KAAK,EAAE1E,SAAS,CAAC,CAAC,GAAGS,QAAQ;IAC7BgE,MAAM,EAAE4B,QAAQ;IAChBlD,YAAY,EAAEtC,QAAQ,CAACW,MAAM,CAAC8E;EAClC,CAAC;AACL","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}