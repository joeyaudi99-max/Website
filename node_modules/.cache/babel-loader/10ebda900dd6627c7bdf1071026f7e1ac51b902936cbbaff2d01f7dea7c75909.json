{"ast":null,"code":"import { countOffset, defaultDensityFactor, defaultRemoveQuantity, deleteCount, errorPrefix, lengthOffset, minCount, minIndex, minLimit, posOffset, qTreeCapacity, sizeFactor, squareExp } from \"./Utils/Constants.js\";\nimport { getLogger, getPosition } from \"../Utils/Utils.js\";\nimport { EventType } from \"../Enums/Types/EventType.js\";\nimport { InteractionManager } from \"./Utils/InteractionManager.js\";\nimport { LimitMode } from \"../Enums/Modes/LimitMode.js\";\nimport { Particle } from \"./Particle.js\";\nimport { Point } from \"./Utils/Point.js\";\nimport { QuadTree } from \"./Utils/QuadTree.js\";\nimport { Rectangle } from \"./Utils/Ranges.js\";\nconst qTreeRectangle = canvasSize => {\n  const {\n    height,\n    width\n  } = canvasSize;\n  return new Rectangle(posOffset * width, posOffset * height, sizeFactor * width, sizeFactor * height);\n};\nexport class Particles {\n  constructor(engine, container) {\n    var _this = this;\n    this._addToPool = function () {\n      _this._pool.push(...arguments);\n    };\n    this._applyDensity = (options, manualCount, group, groupOptions) => {\n      var _options$number$densi;\n      const numberOptions = options.number;\n      if (!((_options$number$densi = options.number.density) !== null && _options$number$densi !== void 0 && _options$number$densi.enable)) {\n        var _groupOptions$number$, _groupOptions$number$2;\n        if (group === undefined) {\n          this._limit = numberOptions.limit.value;\n        } else if ((_groupOptions$number$ = groupOptions === null || groupOptions === void 0 || (_groupOptions$number$2 = groupOptions.number.limit) === null || _groupOptions$number$2 === void 0 ? void 0 : _groupOptions$number$2.value) !== null && _groupOptions$number$ !== void 0 ? _groupOptions$number$ : numberOptions.limit.value) {\n          var _groupOptions$number$3, _groupOptions$number$4;\n          this._groupLimits.set(group, (_groupOptions$number$3 = groupOptions === null || groupOptions === void 0 || (_groupOptions$number$4 = groupOptions.number.limit) === null || _groupOptions$number$4 === void 0 ? void 0 : _groupOptions$number$4.value) !== null && _groupOptions$number$3 !== void 0 ? _groupOptions$number$3 : numberOptions.limit.value);\n        }\n        return;\n      }\n      const densityFactor = this._initDensityFactor(numberOptions.density),\n        optParticlesNumber = numberOptions.value,\n        optParticlesLimit = numberOptions.limit.value > minLimit ? numberOptions.limit.value : optParticlesNumber,\n        particlesNumber = Math.min(optParticlesNumber, optParticlesLimit) * densityFactor + manualCount,\n        particlesCount = Math.min(this.count, this.filter(t => t.group === group).length);\n      if (group === undefined) {\n        this._limit = numberOptions.limit.value * densityFactor;\n      } else {\n        this._groupLimits.set(group, numberOptions.limit.value * densityFactor);\n      }\n      if (particlesCount < particlesNumber) {\n        this.push(Math.abs(particlesNumber - particlesCount), undefined, options, group);\n      } else if (particlesCount > particlesNumber) {\n        this.removeQuantity(particlesCount - particlesNumber, group);\n      }\n    };\n    this._initDensityFactor = densityOptions => {\n      const container = this._container;\n      if (!container.canvas.element || !densityOptions.enable) {\n        return defaultDensityFactor;\n      }\n      const canvas = container.canvas.element,\n        pxRatio = container.retina.pixelRatio;\n      return canvas.width * canvas.height / (densityOptions.height * densityOptions.width * pxRatio ** squareExp);\n    };\n    this._pushParticle = (position, overrideOptions, group, initializer) => {\n      try {\n        let particle = this._pool.pop();\n        if (!particle) {\n          particle = new Particle(this._engine, this._container);\n        }\n        particle.init(this._nextId, position, overrideOptions, group);\n        let canAdd = true;\n        if (initializer) {\n          canAdd = initializer(particle);\n        }\n        if (!canAdd) {\n          return;\n        }\n        this._array.push(particle);\n        this._zArray.push(particle);\n        this._nextId++;\n        this._engine.dispatchEvent(EventType.particleAdded, {\n          container: this._container,\n          data: {\n            particle\n          }\n        });\n        return particle;\n      } catch (e) {\n        getLogger().warning(\"\".concat(errorPrefix, \" adding particle: \").concat(e));\n      }\n    };\n    this._removeParticle = (index, group, override) => {\n      const particle = this._array[index];\n      if (!particle || particle.group !== group) {\n        return false;\n      }\n      const zIdx = this._zArray.indexOf(particle);\n      this._array.splice(index, deleteCount);\n      this._zArray.splice(zIdx, deleteCount);\n      particle.destroy(override);\n      this._engine.dispatchEvent(EventType.particleRemoved, {\n        container: this._container,\n        data: {\n          particle\n        }\n      });\n      this._addToPool(particle);\n      return true;\n    };\n    this._engine = engine;\n    this._container = container;\n    this._nextId = 0;\n    this._array = [];\n    this._zArray = [];\n    this._pool = [];\n    this._limit = 0;\n    this._groupLimits = new Map();\n    this._needsSort = false;\n    this._lastZIndex = 0;\n    this._interactionManager = new InteractionManager(engine, container);\n    this._pluginsInitialized = false;\n    const canvasSize = container.canvas.size;\n    this.quadTree = new QuadTree(qTreeRectangle(canvasSize), qTreeCapacity);\n    this.movers = [];\n    this.updaters = [];\n  }\n  get count() {\n    return this._array.length;\n  }\n  addManualParticles() {\n    const container = this._container,\n      options = container.actualOptions;\n    options.manualParticles.forEach(p => this.addParticle(p.position ? getPosition(p.position, container.canvas.size) : undefined, p.options));\n  }\n  addParticle(position, overrideOptions, group, initializer) {\n    var _this$_groupLimits$ge;\n    const limitMode = this._container.actualOptions.particles.number.limit.mode,\n      limit = group === undefined ? this._limit : (_this$_groupLimits$ge = this._groupLimits.get(group)) !== null && _this$_groupLimits$ge !== void 0 ? _this$_groupLimits$ge : this._limit,\n      currentCount = this.count;\n    if (limit > minLimit) {\n      switch (limitMode) {\n        case LimitMode.delete:\n          {\n            const countToRemove = currentCount + countOffset - limit;\n            if (countToRemove > minCount) {\n              this.removeQuantity(countToRemove);\n            }\n            break;\n          }\n        case LimitMode.wait:\n          if (currentCount >= limit) {\n            return;\n          }\n          break;\n      }\n    }\n    return this._pushParticle(position, overrideOptions, group, initializer);\n  }\n  clear() {\n    this._array = [];\n    this._zArray = [];\n    this._pluginsInitialized = false;\n  }\n  destroy() {\n    this._array = [];\n    this._zArray = [];\n    this.movers = [];\n    this.updaters = [];\n  }\n  draw(delta) {\n    const container = this._container,\n      canvas = container.canvas;\n    canvas.clear();\n    this.update(delta);\n    for (const plugin of container.plugins.values()) {\n      canvas.drawPlugin(plugin, delta);\n    }\n    for (const p of this._zArray) {\n      p.draw(delta);\n    }\n  }\n  filter(condition) {\n    return this._array.filter(condition);\n  }\n  find(condition) {\n    return this._array.find(condition);\n  }\n  get(index) {\n    return this._array[index];\n  }\n  handleClickMode(mode) {\n    this._interactionManager.handleClickMode(mode);\n  }\n  async init() {\n    const container = this._container,\n      options = container.actualOptions;\n    this._lastZIndex = 0;\n    this._needsSort = false;\n    await this.initPlugins();\n    let handled = false;\n    for (const plugin of container.plugins.values()) {\n      var _plugin$particlesInit, _plugin$particlesInit2;\n      handled = (_plugin$particlesInit = (_plugin$particlesInit2 = plugin.particlesInitialization) === null || _plugin$particlesInit2 === void 0 ? void 0 : _plugin$particlesInit2.call(plugin)) !== null && _plugin$particlesInit !== void 0 ? _plugin$particlesInit : handled;\n      if (handled) {\n        break;\n      }\n    }\n    this.addManualParticles();\n    if (!handled) {\n      const particlesOptions = options.particles,\n        groups = particlesOptions.groups;\n      for (const group in groups) {\n        const groupOptions = groups[group];\n        for (let i = this.count, j = 0; j < ((_groupOptions$number = groupOptions.number) === null || _groupOptions$number === void 0 ? void 0 : _groupOptions$number.value) && i < particlesOptions.number.value; i++, j++) {\n          var _groupOptions$number;\n          this.addParticle(undefined, groupOptions, group);\n        }\n      }\n      for (let i = this.count; i < particlesOptions.number.value; i++) {\n        this.addParticle();\n      }\n    }\n  }\n  async initPlugins() {\n    if (this._pluginsInitialized) {\n      return;\n    }\n    const container = this._container;\n    this.movers = await this._engine.getMovers(container, true);\n    this.updaters = await this._engine.getUpdaters(container, true);\n    await this._interactionManager.init();\n    for (const pathGenerator of container.pathGenerators.values()) {\n      pathGenerator.init(container);\n    }\n  }\n  push(nb, mouse, overrideOptions, group) {\n    for (let i = 0; i < nb; i++) {\n      this.addParticle(mouse === null || mouse === void 0 ? void 0 : mouse.position, overrideOptions, group);\n    }\n  }\n  async redraw() {\n    this.clear();\n    await this.init();\n    this.draw({\n      value: 0,\n      factor: 0\n    });\n  }\n  remove(particle, group, override) {\n    this.removeAt(this._array.indexOf(particle), undefined, group, override);\n  }\n  removeAt(index) {\n    let quantity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultRemoveQuantity;\n    let group = arguments.length > 2 ? arguments[2] : undefined;\n    let override = arguments.length > 3 ? arguments[3] : undefined;\n    if (index < minIndex || index > this.count) {\n      return;\n    }\n    let deleted = 0;\n    for (let i = index; deleted < quantity && i < this.count; i++) {\n      if (this._removeParticle(i, group, override)) {\n        i--;\n        deleted++;\n      }\n    }\n  }\n  removeQuantity(quantity, group) {\n    this.removeAt(minIndex, quantity, group);\n  }\n  setDensity() {\n    const options = this._container.actualOptions,\n      groups = options.particles.groups,\n      manualCount = options.manualParticles.length;\n    for (const group in groups) {\n      this._applyDensity(groups[group], manualCount, group);\n    }\n    this._applyDensity(options.particles, manualCount);\n  }\n  setLastZIndex(zIndex) {\n    this._lastZIndex = zIndex;\n    this._needsSort = this._needsSort || this._lastZIndex < zIndex;\n  }\n  setResizeFactor(factor) {\n    this._resizeFactor = factor;\n  }\n  update(delta) {\n    const container = this._container,\n      particlesToDelete = new Set();\n    this.quadTree = new QuadTree(qTreeRectangle(container.canvas.size), qTreeCapacity);\n    for (const pathGenerator of container.pathGenerators.values()) {\n      pathGenerator.update();\n    }\n    for (const plugin of container.plugins.values()) {\n      var _plugin$update;\n      (_plugin$update = plugin.update) === null || _plugin$update === void 0 || _plugin$update.call(plugin, delta);\n    }\n    const resizeFactor = this._resizeFactor;\n    for (const particle of this._array) {\n      if (resizeFactor && !particle.ignoresResizeRatio) {\n        particle.position.x *= resizeFactor.width;\n        particle.position.y *= resizeFactor.height;\n        particle.initialPosition.x *= resizeFactor.width;\n        particle.initialPosition.y *= resizeFactor.height;\n      }\n      particle.ignoresResizeRatio = false;\n      this._interactionManager.reset(particle);\n      for (const plugin of this._container.plugins.values()) {\n        var _plugin$particleUpdat;\n        if (particle.destroyed) {\n          break;\n        }\n        (_plugin$particleUpdat = plugin.particleUpdate) === null || _plugin$particleUpdat === void 0 || _plugin$particleUpdat.call(plugin, particle, delta);\n      }\n      for (const mover of this.movers) {\n        if (mover.isEnabled(particle)) {\n          mover.move(particle, delta);\n        }\n      }\n      if (particle.destroyed) {\n        particlesToDelete.add(particle);\n        continue;\n      }\n      this.quadTree.insert(new Point(particle.getPosition(), particle));\n    }\n    if (particlesToDelete.size) {\n      const checkDelete = p => !particlesToDelete.has(p);\n      this._array = this.filter(checkDelete);\n      this._zArray = this._zArray.filter(checkDelete);\n      for (const particle of particlesToDelete) {\n        this._engine.dispatchEvent(EventType.particleRemoved, {\n          container: this._container,\n          data: {\n            particle\n          }\n        });\n      }\n      this._addToPool(...particlesToDelete);\n    }\n    this._interactionManager.externalInteract(delta);\n    for (const particle of this._array) {\n      for (const updater of this.updaters) {\n        updater.update(particle, delta);\n      }\n      if (!particle.destroyed && !particle.spawning) {\n        this._interactionManager.particlesInteract(particle, delta);\n      }\n    }\n    delete this._resizeFactor;\n    if (this._needsSort) {\n      const zArray = this._zArray;\n      zArray.sort((a, b) => b.position.z - a.position.z || a.id - b.id);\n      this._lastZIndex = zArray[zArray.length - lengthOffset].position.z;\n      this._needsSort = false;\n    }\n  }\n}","map":{"version":3,"names":["countOffset","defaultDensityFactor","defaultRemoveQuantity","deleteCount","errorPrefix","lengthOffset","minCount","minIndex","minLimit","posOffset","qTreeCapacity","sizeFactor","squareExp","getLogger","getPosition","EventType","InteractionManager","LimitMode","Particle","Point","QuadTree","Rectangle","qTreeRectangle","canvasSize","height","width","Particles","constructor","engine","container","_this","_addToPool","_pool","push","arguments","_applyDensity","options","manualCount","group","groupOptions","_options$number$densi","numberOptions","number","density","enable","_groupOptions$number$","_groupOptions$number$2","undefined","_limit","limit","value","_groupOptions$number$3","_groupOptions$number$4","_groupLimits","set","densityFactor","_initDensityFactor","optParticlesNumber","optParticlesLimit","particlesNumber","Math","min","particlesCount","count","filter","t","length","abs","removeQuantity","densityOptions","_container","canvas","element","pxRatio","retina","pixelRatio","_pushParticle","position","overrideOptions","initializer","particle","pop","_engine","init","_nextId","canAdd","_array","_zArray","dispatchEvent","particleAdded","data","e","warning","concat","_removeParticle","index","override","zIdx","indexOf","splice","destroy","particleRemoved","Map","_needsSort","_lastZIndex","_interactionManager","_pluginsInitialized","size","quadTree","movers","updaters","addManualParticles","actualOptions","manualParticles","forEach","p","addParticle","_this$_groupLimits$ge","limitMode","particles","mode","get","currentCount","delete","countToRemove","wait","clear","draw","delta","update","plugin","plugins","values","drawPlugin","condition","find","handleClickMode","initPlugins","handled","_plugin$particlesInit","_plugin$particlesInit2","particlesInitialization","call","particlesOptions","groups","i","j","_groupOptions$number","getMovers","getUpdaters","pathGenerator","pathGenerators","nb","mouse","redraw","factor","remove","removeAt","quantity","deleted","setDensity","setLastZIndex","zIndex","setResizeFactor","_resizeFactor","particlesToDelete","Set","_plugin$update","resizeFactor","ignoresResizeRatio","x","y","initialPosition","reset","_plugin$particleUpdat","destroyed","particleUpdate","mover","isEnabled","move","add","insert","checkDelete","has","externalInteract","updater","spawning","particlesInteract","zArray","sort","a","b","z","id"],"sources":["C:/Users/Joey/Documents/Website/node_modules/@tsparticles/engine/browser/Core/Particles.js"],"sourcesContent":["import { countOffset, defaultDensityFactor, defaultRemoveQuantity, deleteCount, errorPrefix, lengthOffset, minCount, minIndex, minLimit, posOffset, qTreeCapacity, sizeFactor, squareExp, } from \"./Utils/Constants.js\";\nimport { getLogger, getPosition } from \"../Utils/Utils.js\";\nimport { EventType } from \"../Enums/Types/EventType.js\";\nimport { InteractionManager } from \"./Utils/InteractionManager.js\";\nimport { LimitMode } from \"../Enums/Modes/LimitMode.js\";\nimport { Particle } from \"./Particle.js\";\nimport { Point } from \"./Utils/Point.js\";\nimport { QuadTree } from \"./Utils/QuadTree.js\";\nimport { Rectangle } from \"./Utils/Ranges.js\";\nconst qTreeRectangle = (canvasSize) => {\n    const { height, width } = canvasSize;\n    return new Rectangle(posOffset * width, posOffset * height, sizeFactor * width, sizeFactor * height);\n};\nexport class Particles {\n    constructor(engine, container) {\n        this._addToPool = (...particles) => {\n            this._pool.push(...particles);\n        };\n        this._applyDensity = (options, manualCount, group, groupOptions) => {\n            const numberOptions = options.number;\n            if (!options.number.density?.enable) {\n                if (group === undefined) {\n                    this._limit = numberOptions.limit.value;\n                }\n                else if (groupOptions?.number.limit?.value ?? numberOptions.limit.value) {\n                    this._groupLimits.set(group, groupOptions?.number.limit?.value ?? numberOptions.limit.value);\n                }\n                return;\n            }\n            const densityFactor = this._initDensityFactor(numberOptions.density), optParticlesNumber = numberOptions.value, optParticlesLimit = numberOptions.limit.value > minLimit ? numberOptions.limit.value : optParticlesNumber, particlesNumber = Math.min(optParticlesNumber, optParticlesLimit) * densityFactor + manualCount, particlesCount = Math.min(this.count, this.filter(t => t.group === group).length);\n            if (group === undefined) {\n                this._limit = numberOptions.limit.value * densityFactor;\n            }\n            else {\n                this._groupLimits.set(group, numberOptions.limit.value * densityFactor);\n            }\n            if (particlesCount < particlesNumber) {\n                this.push(Math.abs(particlesNumber - particlesCount), undefined, options, group);\n            }\n            else if (particlesCount > particlesNumber) {\n                this.removeQuantity(particlesCount - particlesNumber, group);\n            }\n        };\n        this._initDensityFactor = densityOptions => {\n            const container = this._container;\n            if (!container.canvas.element || !densityOptions.enable) {\n                return defaultDensityFactor;\n            }\n            const canvas = container.canvas.element, pxRatio = container.retina.pixelRatio;\n            return (canvas.width * canvas.height) / (densityOptions.height * densityOptions.width * pxRatio ** squareExp);\n        };\n        this._pushParticle = (position, overrideOptions, group, initializer) => {\n            try {\n                let particle = this._pool.pop();\n                if (!particle) {\n                    particle = new Particle(this._engine, this._container);\n                }\n                particle.init(this._nextId, position, overrideOptions, group);\n                let canAdd = true;\n                if (initializer) {\n                    canAdd = initializer(particle);\n                }\n                if (!canAdd) {\n                    return;\n                }\n                this._array.push(particle);\n                this._zArray.push(particle);\n                this._nextId++;\n                this._engine.dispatchEvent(EventType.particleAdded, {\n                    container: this._container,\n                    data: {\n                        particle,\n                    },\n                });\n                return particle;\n            }\n            catch (e) {\n                getLogger().warning(`${errorPrefix} adding particle: ${e}`);\n            }\n        };\n        this._removeParticle = (index, group, override) => {\n            const particle = this._array[index];\n            if (!particle || particle.group !== group) {\n                return false;\n            }\n            const zIdx = this._zArray.indexOf(particle);\n            this._array.splice(index, deleteCount);\n            this._zArray.splice(zIdx, deleteCount);\n            particle.destroy(override);\n            this._engine.dispatchEvent(EventType.particleRemoved, {\n                container: this._container,\n                data: {\n                    particle,\n                },\n            });\n            this._addToPool(particle);\n            return true;\n        };\n        this._engine = engine;\n        this._container = container;\n        this._nextId = 0;\n        this._array = [];\n        this._zArray = [];\n        this._pool = [];\n        this._limit = 0;\n        this._groupLimits = new Map();\n        this._needsSort = false;\n        this._lastZIndex = 0;\n        this._interactionManager = new InteractionManager(engine, container);\n        this._pluginsInitialized = false;\n        const canvasSize = container.canvas.size;\n        this.quadTree = new QuadTree(qTreeRectangle(canvasSize), qTreeCapacity);\n        this.movers = [];\n        this.updaters = [];\n    }\n    get count() {\n        return this._array.length;\n    }\n    addManualParticles() {\n        const container = this._container, options = container.actualOptions;\n        options.manualParticles.forEach(p => this.addParticle(p.position ? getPosition(p.position, container.canvas.size) : undefined, p.options));\n    }\n    addParticle(position, overrideOptions, group, initializer) {\n        const limitMode = this._container.actualOptions.particles.number.limit.mode, limit = group === undefined ? this._limit : (this._groupLimits.get(group) ?? this._limit), currentCount = this.count;\n        if (limit > minLimit) {\n            switch (limitMode) {\n                case LimitMode.delete: {\n                    const countToRemove = currentCount + countOffset - limit;\n                    if (countToRemove > minCount) {\n                        this.removeQuantity(countToRemove);\n                    }\n                    break;\n                }\n                case LimitMode.wait:\n                    if (currentCount >= limit) {\n                        return;\n                    }\n                    break;\n            }\n        }\n        return this._pushParticle(position, overrideOptions, group, initializer);\n    }\n    clear() {\n        this._array = [];\n        this._zArray = [];\n        this._pluginsInitialized = false;\n    }\n    destroy() {\n        this._array = [];\n        this._zArray = [];\n        this.movers = [];\n        this.updaters = [];\n    }\n    draw(delta) {\n        const container = this._container, canvas = container.canvas;\n        canvas.clear();\n        this.update(delta);\n        for (const plugin of container.plugins.values()) {\n            canvas.drawPlugin(plugin, delta);\n        }\n        for (const p of this._zArray) {\n            p.draw(delta);\n        }\n    }\n    filter(condition) {\n        return this._array.filter(condition);\n    }\n    find(condition) {\n        return this._array.find(condition);\n    }\n    get(index) {\n        return this._array[index];\n    }\n    handleClickMode(mode) {\n        this._interactionManager.handleClickMode(mode);\n    }\n    async init() {\n        const container = this._container, options = container.actualOptions;\n        this._lastZIndex = 0;\n        this._needsSort = false;\n        await this.initPlugins();\n        let handled = false;\n        for (const plugin of container.plugins.values()) {\n            handled = plugin.particlesInitialization?.() ?? handled;\n            if (handled) {\n                break;\n            }\n        }\n        this.addManualParticles();\n        if (!handled) {\n            const particlesOptions = options.particles, groups = particlesOptions.groups;\n            for (const group in groups) {\n                const groupOptions = groups[group];\n                for (let i = this.count, j = 0; j < groupOptions.number?.value && i < particlesOptions.number.value; i++, j++) {\n                    this.addParticle(undefined, groupOptions, group);\n                }\n            }\n            for (let i = this.count; i < particlesOptions.number.value; i++) {\n                this.addParticle();\n            }\n        }\n    }\n    async initPlugins() {\n        if (this._pluginsInitialized) {\n            return;\n        }\n        const container = this._container;\n        this.movers = await this._engine.getMovers(container, true);\n        this.updaters = await this._engine.getUpdaters(container, true);\n        await this._interactionManager.init();\n        for (const pathGenerator of container.pathGenerators.values()) {\n            pathGenerator.init(container);\n        }\n    }\n    push(nb, mouse, overrideOptions, group) {\n        for (let i = 0; i < nb; i++) {\n            this.addParticle(mouse?.position, overrideOptions, group);\n        }\n    }\n    async redraw() {\n        this.clear();\n        await this.init();\n        this.draw({ value: 0, factor: 0 });\n    }\n    remove(particle, group, override) {\n        this.removeAt(this._array.indexOf(particle), undefined, group, override);\n    }\n    removeAt(index, quantity = defaultRemoveQuantity, group, override) {\n        if (index < minIndex || index > this.count) {\n            return;\n        }\n        let deleted = 0;\n        for (let i = index; deleted < quantity && i < this.count; i++) {\n            if (this._removeParticle(i, group, override)) {\n                i--;\n                deleted++;\n            }\n        }\n    }\n    removeQuantity(quantity, group) {\n        this.removeAt(minIndex, quantity, group);\n    }\n    setDensity() {\n        const options = this._container.actualOptions, groups = options.particles.groups, manualCount = options.manualParticles.length;\n        for (const group in groups) {\n            this._applyDensity(groups[group], manualCount, group);\n        }\n        this._applyDensity(options.particles, manualCount);\n    }\n    setLastZIndex(zIndex) {\n        this._lastZIndex = zIndex;\n        this._needsSort = this._needsSort || this._lastZIndex < zIndex;\n    }\n    setResizeFactor(factor) {\n        this._resizeFactor = factor;\n    }\n    update(delta) {\n        const container = this._container, particlesToDelete = new Set();\n        this.quadTree = new QuadTree(qTreeRectangle(container.canvas.size), qTreeCapacity);\n        for (const pathGenerator of container.pathGenerators.values()) {\n            pathGenerator.update();\n        }\n        for (const plugin of container.plugins.values()) {\n            plugin.update?.(delta);\n        }\n        const resizeFactor = this._resizeFactor;\n        for (const particle of this._array) {\n            if (resizeFactor && !particle.ignoresResizeRatio) {\n                particle.position.x *= resizeFactor.width;\n                particle.position.y *= resizeFactor.height;\n                particle.initialPosition.x *= resizeFactor.width;\n                particle.initialPosition.y *= resizeFactor.height;\n            }\n            particle.ignoresResizeRatio = false;\n            this._interactionManager.reset(particle);\n            for (const plugin of this._container.plugins.values()) {\n                if (particle.destroyed) {\n                    break;\n                }\n                plugin.particleUpdate?.(particle, delta);\n            }\n            for (const mover of this.movers) {\n                if (mover.isEnabled(particle)) {\n                    mover.move(particle, delta);\n                }\n            }\n            if (particle.destroyed) {\n                particlesToDelete.add(particle);\n                continue;\n            }\n            this.quadTree.insert(new Point(particle.getPosition(), particle));\n        }\n        if (particlesToDelete.size) {\n            const checkDelete = (p) => !particlesToDelete.has(p);\n            this._array = this.filter(checkDelete);\n            this._zArray = this._zArray.filter(checkDelete);\n            for (const particle of particlesToDelete) {\n                this._engine.dispatchEvent(EventType.particleRemoved, {\n                    container: this._container,\n                    data: {\n                        particle,\n                    },\n                });\n            }\n            this._addToPool(...particlesToDelete);\n        }\n        this._interactionManager.externalInteract(delta);\n        for (const particle of this._array) {\n            for (const updater of this.updaters) {\n                updater.update(particle, delta);\n            }\n            if (!particle.destroyed && !particle.spawning) {\n                this._interactionManager.particlesInteract(particle, delta);\n            }\n        }\n        delete this._resizeFactor;\n        if (this._needsSort) {\n            const zArray = this._zArray;\n            zArray.sort((a, b) => b.position.z - a.position.z || a.id - b.id);\n            this._lastZIndex = zArray[zArray.length - lengthOffset].position.z;\n            this._needsSort = false;\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}